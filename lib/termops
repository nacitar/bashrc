#!/bin/env bash

# if the framework is sourced
if type -p NX_FRAMEWORK_SOURCED &>/dev/null; then

	nx_library "platform"

	nx_dealias nx_tput_value
	nx_tput_value()
	{
		# invokes tput if possible, if no output is obtained or tput doesn't exit
		# the default value is used.
		# usage: nx_tput_value [default] [command]
		[ $# -lt 2 ] && return 1
		local def_val="$1"
		shift
		local ret=""
		if type -P tput &>/dev/null; then
			ret="$(tput "$@" 2>/dev/null)"
			code=$?
		fi
		[ -n "$ret" ] && echo "$ret" || echo "$def_val"
		return $code
	}
	nx_dealias nx_tput_cmd
	nx_tput_cmd()
	{
		# this one doesn't take a default value
		nx_tput_value "" "$@" &>/dev/null
	}
	nx_dealias nx_tput_term_fg
	nx_tput_term_fg()
	{
		[ $# -ne 1 ] || ! nx_isnum "$1" || [ "$1" -lt 0 ] || [ "$1" -gt 256 ] && return 1

		local def=""
		if [ "$1" -lt 8 ]; then
			def="\e[$((30+$1-8))m"
		elif [ "$1" -lt 16 ]; then
			def="\e[$((90+$1-16))m"
		elif [ "$1" -lt 256 ]; then
			def="\e[38;5;$1m"
		fi

		nx_tput_value "$def" setaf "$1"
	}
	nx_dealias nx_tput_term_bg
	nx_tput_term_bg()
	{
		[ $# -ne 1 ] || ! nx_isnum "$1" || [ "$1" -lt 0 ] || [ "$1" -gt 256 ] && return 1

		local def=""
		if [ "$1" -lt 8 ]; then
			def="\e[$((40+$1))m"
		elif [ "$1" -lt 16 ]; then
			def="\e[$((100+$1))m"
		elif [ "$1" -lt 256 ]; then
			def="\e[48;5;$1m"
		fi

		nx_tput_value "$def" setab "$1"
	}
	nx_dealias nx_tput_term_bold
	nx_tput_term_bold()
	{
		nx_tput_value "\e[1m" bold
	}
	nx_dealias nx_tput_term_underline
	nx_tput_term_underline()
	{
		nx_tput_value "\e[4m" smul
	}
	nx_dealias nx_tput_term_reverse
	nx_tput_term_reverse()
	{
		nx_tput_value "\e[7m" rev
	}
	nx_dealias nx_tput_term_italic
	nx_tput_term_italic()
	{
		nx_tput_value "\e[3m" sitm
	}
	nx_dealias nx_tput_term_normal
	nx_tput_term_normal()
	{
		nx_tput_value "\e[m\0" sgr0
	}
	nx_dealias nx_tput_terminfo_exists
	nx_tput_terminfo_exists()
	{
		[ $# -ne 1 ] && return 1
		nx_tput_cmd -T"$1" -S </dev/null
	}
	nx_dealias nx_tput_terminfo_colors
	nx_tput_terminfo_colors()
	{
		local value
		value="$(nx_tput_value "-1" colors)"
		ret=$?
		if [ "$value" == "-1" ]; then
			# attempt to use term to find the colors
			case "$TERM" in
				*color*)
					# get the number before 'color'
					value="${TERM%%color*}"
					value="${value##*[![:digit:]]}"

					if [ -z "$value" ]; then
						# it has color in the name, we just don't see that it has colors
						value="8"
					fi
					;;
			esac
		fi

		echo "$value"

		# a value of -1 indicates no colors
		[ "$value" == "-1" ] && return 1
		# return the error value of the tput command
		return $ret
	}
	nx_dealias nx_check_term
	nx_check_term()
	{
		nx_set_term "$TERM"
	}
	# sets the term, and also fixes bugs in terminfo files if necessary
	nx_dealias nx_set_term
	nx_set_term()
	{
		if [ $# -ne 1 ]; then
			return 1
		else
			local new_term="$1"
		fi

		# we can skip all of this if the processed-term value matches the one we set
		if [ "$new_term" != "$NX_TERM" ]; then
			# screen's terminfo has an error with regard to italics, if the fixed terminfo
			# is present, use it instead
			# http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ
			case "$new_term" in
				xterm)
					fixed_term="xterm-256color"
					nx_tput_terminfo_exists "$fixed_term" && new_term="$fixed_term"
				;;
				screen*)
					local screen="screen"
					local screen256="screen-256color"
					local iterm
					if nx_has_terminfo_tools && nx_has_sed; then
						for iterm in "$screen" "$screen256"; do
							if nx_tput_terminfo_exists "$iterm" && ! infocmp "$iterm" | grep 'ritm=' &>/dev/null; then
								local tfile="$(mktemp "/tmp/nxtermops.XXXXXXX")"
								[ -e "$tfile" ] || tfile="~/tmpterminfo.tmp"

								# adapted from http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ
								# fixes bug in screen terminfo with regard to reverse/italics.
								infocmp "$iterm" | sed \
									-e 's/%?%p1%t;3%/%?%p1%t;7%/' \
									-e 's/smso=[^,]*,/smso=\\E[7m,/' \
									-e 's/rmso=[^,]*,/rmso=\\E[27m,/' \
									-e '$s/$/ sitm=\\E[3m, ritm=\\E[23m,/' > "$tfile"
								tic "$tfile"
								rm -f "$tfile"
							fi
						done
					fi
					nx_tput_terminfo_exists "$screen256" || new_term="$screen"
				;;
				rxvt-unicode*)
					local urxvt="rxvt-unicode"
					local urxvt256="rxvt-unicode-256color"
					local iterm
					if nx_has_terminfo_tools && nx_has_sed; then
						# adapted from https://bugzilla.redhat.com/show_bug.cgi?id=718506
						# fix alt-2 keypress in terminfo; fixed upstream!
						for iterm in "$urxvt" "$urxvt256"; do
							if nx_tput_terminfo_exists "$iterm" && infocmp "$iterm" | grep 'kIC=\\E2\$' &>/dev/null; then
								local tfile="$(mktemp "/tmp/nxtermops.XXXXXXX")"
								[ -e "$tfile" ] || tfile="~/tmpterminfo.tmp"
								# replace the code, adding a [ where it was missing
								infocmp "$iterm" | sed 's/\(kIC=\\E\)\(2\$\)/\1[\2/' > "$tfile" 
								tic "$tfile"
								rm -f "$tfile"
							fi
						done
						# create 256color terminfo if necessary; frequently not shipped
						if [ "$new_term" == "$urxvt256" ]; then
							if ! nx_tput_terminfo_exists "$urxvt256" && nx_tput_terminfo_exists "$urxvt"; then
								local tfile="$(mktemp "/tmp/nxtermops.XXXXXXX")"
								[ -e "$tfile" ] || tfile="~/tmpterminfo.tmp"
								infocmp "$urxvt" | sed 's/rxvt-unicode/rxvt-unicode-256color/;s/colors#88/colors#256/;s/pairs#7744/pairs#32767/' > "$tfile"
								tic "$tfile"
								rm -f "$tfile"
							fi
						fi

					fi
				;;
			esac

			# this check is not redundant, as the term is now processed
			if [ "$new_term" != "$TERM" ]; then
				export TERM="$new_term"
				nx_tput_cmd init
			fi

			# cache colors if new, or if no cache present
			if [ "$NX_TERM" != "$TERM" ]; then
				NX_TERM="$TERM"
				local i=0
				while [ $i -lt 16 ];
				do
					NX_TERM_FG["$i"]="$(nx_tput_term_fg "$i")"
					NX_TERM_BG["$i"]="$(nx_tput_term_bg "$i")"
					((i++))
				done
				NX_TERM_BOLD="$(nx_tput_term_bold)"
				NX_TERM_ITALIC="$(nx_tput_term_italic)"
				NX_TERM_REVERSE="$(nx_tput_term_reverse)"
				NX_TERM_UNDERLINE="$(nx_tput_term_underline)"
				NX_TERM_NORMAL="$(nx_tput_term_normal)"

				NX_TERM_COLORS="$(nx_tput_terminfo_colors)"
				if ! nx_isnum "$NX_TERM_COLORS" || [ "$NX_TERM_COLORS" -lt 8 ]; then
					# less than 8 might as well be 0, for our usage
					unset NX_TERM_COLORS
				fi
			fi
		fi

		return 0
	}

	nx_dealias nx_color_test
	nx_color_test()
	{
		local T='  gYw  '   # The test text
		local fg_color
		local fg_str
		local bg_color
		local bg_str
		local fg_escape_str
		local bg_escape_str
		# headers
		echo -en "  "
		bg_color=-1
		while [ "$bg_color" -lt 16 ];
		do
			[ "$bg_color" -lt 10 ] && bg_str=" $bg_color" || bg_str="$bg_color"
			[ "$bg_color" == "-1" ] && bg_str="bg"
			echo -en "   $bg_str  "
			((bg_color++))
		done
		echo
		fg_color=-1
		while [ "$fg_color" -lt 16 ];
		do
			[ "$fg_color" -lt 10 ] && fg_str=" $fg_color" || fg_str="$fg_color"
			[ "$fg_color" -lt 0 ] && fg_str="fg" && fg_escape_str="" || fg_escape_str="${NX_TERM_FG["$fg_color"]}"
			echo -en "$fg_str $escape_str$T"
			bg_color=0
			while [ "$bg_color" -lt 16 ];
			do
				if [ "$bg_color" -lt 0 ]; then
					bg_str="  "
					bg_escape_str=""
				else
					[ "$bg_color" -lt 10 ] && bg_str=" $bg_color" || bg_str="$bg_color"
					bg_escape_str="${NX_TERM_BG["$bg_color"]}"
				fi
				echo -en "$fg_escape_str$bg_escape_str$T${NX_TERM_NORMAL}"
				((bg_color++))
			done
			echo
			((fg_color++))
		done
	}
	# a preferred bash prompt, colorizing brackets according to exit codes
	nx_dealias nx_bash_prompt
	nx_bash_prompt()
	{
		# enclosing all escape sequences with \[ \] so it doesn't contribute to the line's character count
		local ESTAT="\$(ECODE=\$?; [ \$ECODE -eq 0 ] && echo '\[${NX_TERM_FG[4]}\]' || echo '\[${NX_TERM_FG[1]}\]'; exit \$ECODE)"

		# Root prompt ends with #, non-root ends with $
		local DIVCHR="\$(ECODE=\$?; [ \"\$EUID\" -eq 0 ] && echo '#' || echo '\$'; exit \$ECODE)"

		# actual prompt
		# [user@host dir]# 
		if [ -n "$NX_TERM_COLORS" ]; then
			PS1="\[${NX_TERM_NORMAL}\]${NX_CHROOT:+($NX_CHROOT)}${ESTAT}\[${NX_TERM_BOLD}\][\[${NX_TERM_NORMAL}${NX_TERM_FG[2]}\]\u@\h \[${NX_TERM_FG[6]}${NX_TERM_BOLD}\]\w${ESTAT}]${DIVCHR}\[${NX_TERM_NORMAL}\] "
		else
			PS1="${NX_CHROOT:+($NX_CHROOT)}[\u@\h \w]${DIVCHR} "
		fi
	}

fi
