#!/bin/env bash

# if a system has something like "alias mem='top', making a function like 'mem()' actually
# results in making 'top()' so we fix that by dealiasing before creating functions.
unalias nx_dealias &>/dev/null
unset -f nx_dealias &>/dev/null
nx_dealias() {
    unalias "$@" &>/dev/null
    unset -f "$@" &>/dev/null
}
nx_dealias nx_error
nx_error() {
    echo "[ERROR] $@" >&2
}
# exit code indicates success, output is the command name 
nx_dealias nx_path_search
nx_path_search() {
    if [ $# -ne 1 ]; then
        nx_error 'usage: nx_path_search <filename_path_string>'
        return 1
    fi
    type -P "$@" 2>/dev/null
}
# same as path_search, but with a custom PATH 
nx_dealias nx_path_search_custom
nx_path_search_custom() {
    if [ $# -ne 2 ]; then
        nx_error 'usage: nx_path_search_custom <filename_path_string> <search_path>'
        return 1
    fi
    local filename="$1"
    shift
    PATH="$@" nx_path_search "$filename"
}
# runs the actual binary even if an alias is masking it
nx_dealias nx_nonaliased
nx_nonaliased() {
    local cmd="$1"
    shift
    local realapp="$(nx_path_search "$cmd")"
    if ! [ -x "$realapp" ]; then
        nx_error "$cmd command not found"
        return 1
    fi
    "$realapp" "$@"
}
nx_dealias nx_library
nx_library() {
    local f
    local varname
    for f in "$@"; do
        varname="NX_LIB_SOURCED_${f}"
        if ! [ type -p "$varname" &>/dev/null ]; then
            # create the function used to determine if a library has been loaded
            eval "${varname}() { return 0; }" &>/dev/null
            local filename="$NX_LIBRARY_PATH/lib/$f"
            [ -r "$filename" ] && source "$filename" || nx_error "library file \"$f\" could not be sourced." 
        fi
    done
}
# Colorize ls output per the system settings
nx_dealias nx_dircolors
nx_dircolors() {
    local f
    # enable color support of ls
    if type -P dircolors &>/dev/null; then
        # use the first file found, otherwise the defaults
        for f in "$HOME/.dircolors" /etc/DIR_COLORS /etc/dircolors ''
        do
            if [ -r "$f" ]; then eval "$(dircolors -b "$f")"; break; fi
        done
        # if we made it to the empty string, we never found one, so use defaults
        [ -z "$f" ] && eval "$(dircolors -b)"
    fi
}
# Enable bash completion
nx_dealias nx_bash_completion
nx_bash_completion() {
    local f
    # source the first system bash completion script that we find
    for f in /etc/profile.d/bash{-,_}completion{.sh,} /etc/bash_completion
    do
        if [ -r "$f" ]; then
            source "$f"
            break
        fi
    done

    # Allow tab completion after sudo
    complete -cf sudo
}
nx_dealias nx_has_sed
nx_has_sed() {
    nx_path_search sed &>/dev/null
}
nx_dealias nx_isnum
nx_isnum() {
    if [ "$1" -eq "$1" ] &>/dev/null; then
        return 0
    fi
    return 1
}
